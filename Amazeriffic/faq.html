<!DOCTYPE html>
<html>
<head>
	<title>Amazeriffic</title>
	<link rel="stylesheet" type="text/css" href="reset.css">
	<link rel="stylesheet" type="text/css" href="style.css">
	<link href='https://fonts.googleapis.com/css?family=Ubuntu' rel='stylesheet' type='text/css'>
	<link href='https://fonts.googleapis.com/css?family=Droid+Sans' rel='stylesheet' type='text/css'>
</head>
<body>
<!--header part-->
	<header>
		<!--main heading-->
		<div class="container">
			<h1 class="styleitalic">
				Amazeriffic!
			</h1>
			<!--Navigation part-->
			<nav>
				<a href="#">
					Sign Up
				</a> |
				<a href="faq.html">
					FAQ
				</a> |
				<a href="#">
					Support
				</a> 
			</nav>
		</div>
	</header>

<!--Main part-->
	<main>
		<!--div-part-->
		<div>
		<!--heading 1-->
			<h2>
				Frequently Asked Questions.
			</h2>
			<!--content-->
				<div class="maincontentFAQ">
					<h3 class="stylenew">What is CORS? How does it work ?</h3>
					<div class="newstyle">
					<p>
						Cross-origin resource sharing (CORS) is a mechanism that allows many resources (e.g., fonts, JavaScript, etc.) on a web page to be requested from another domain outside the domain from which the resource originated. It’s a mechanism supported in HTML5 that manages XMLHttpRequest access to a domain different.
						CORS adds new HTTP headers that provide access to permitted origin domains. For HTTP methods other than GET (or POST with certain MIME types), the specification mandates that browsers first use an HTTP OPTIONS request header to solicit a list of supported (and available) methods from the server. The actual request can then be submitted. Servers can also notify clients whether “credentials” (including Cookies and HTTP Authentication data) should be sent with requests.
					</p>
					</div>

					<h3 class="stylenew">Explain the purpose of each of HTTP request types when used with RESTful web Service.</h3>
					<div class="newstyle">
					<p>
						The purpose of each of the HTTP request types when used with a RESTful web service is as follows:</p>
						<p>
						GET: Retrieves data from the server (should only retrieve data and should have no other effect).</p>
						<p>
						POST: Sends data to the server for a new entity. It is often used when uploading a file or submitting a completed web form.</p>
						<p>
						PUT: Similar to POST, but used to replace an existing entity.</p>
						<p>
						PATCH: Similar to PUT, but used to update only certain fields within an existing entity.</p>
						<p> 
						DELETE: Removes data from the server.
						</p>
						<p>
						TRACE: Provides a means to test what a machine along the network path receives when a request is made. As such, it simply returns what was sent.</p>
						<p>
						OPTIONS: Allows a client to request information about the request methods supported by a service. The relevant response header is Allow and it simply lists the supported methods. (It can also be used to request information about the request methods supported for the server where the service resides by using a * wildcard in the URI.)</p>
						<p>
						HEAD: Same as the GET method for a resource, but returns only the response headers (i.e., with no entity-body).</p>
						<p>
						CONNECT: Primarily used to establish a network connection to a resource (usually via some proxy that can be requested to forward an HTTP request as TCP and maintain the connection). Once established, the response sends a 200 status code and a “Connection Established” message. 
					</p></div>

					<h3 class="stylenew">
						What is LONG-POLLING, how does it work, and why would you use it? Consider Server-Client resources, what is the main drawback of using LONG-POLLING? Which HTML5 feature is the best alternative to LONG-POLLING?
					</h3>
					<div class="newstyle">
					<p>
						The HTTP protocol is based on a request/response pattern, which means that the server cannot push any data to the client (i.e., the server can only provide data to the client in response to a client request). Long polling is a web application development pattern used to emulate pushing data from server to client. When the long polling pattern is used, the client submits a request to the server and the connection then remains active until the server is ready to send data to the client. The connection is closed only after data is sent back to the client or connection timeout occurs. The client then creates a new request when the connection is closed, thus restarting the loop.
						</p>

						<p>There are two important drawbacks that need to be considered when using long polling:</p>
						<p>
						Long polling requests are not different from any other HTTP request and web servers handle them the same way. This means that every long poll connection will reserve server resources, potentially maxing out the number of connections the server can handle. This can lead to HTTP connection timeouts.</p>
						<p>
						Each web browser will limit the maximum number of connections web application can make. This means that your application load time and performance may be degraded.</p>
						<p>
						In HTML5, a useful alternative to long polling is using a WebSocket. A WebSocket is a protocol providing full-duplex communications channels over a single TCP connection. The WebSocket protocol makes possible more interaction between a browser and a web site, facilitating live content and eliminates the need for the long polling paradigm.
						Another potential answer could be Server-sent DOM Events. Which is method of continuously sending data from a server to the browser, rather than repeatedly requesting it. However, this HTML5 feature is not supported by Microsoft Internet Explorer, thus making it less attractive solution.	
					</p></div>

					<h3 class="stylenew">
						What is an ETag an how does it work?
					</h3>
						<div class="newstyle">
						<p>
							An ETag is an opaque identifier assigned by a web server to a specific version of a resource found at an URL. If the resource content at that URL ever changes, a new and different ETag is assigned.</p>
						<p>
							In typical usage, when an URL is retrieved the web server will return the resource along with its corresponding ETag value, which is placed in an HTTP ETag field:
						</p>
						<p>
							ETag: "unique_id_of_resource_version"
						</p>
						<p>
							The client may then decide to cache the resource, along with its ETag. Later, if the client wants to retrieve the same URL again, it will send its previously saved copy of the ETag along with the request in a "If-None-Match" field.
						</p>
						<p>
							If-None-Match: "unique_id_of_resource_version"
						</p>
						<p>
							On this subsequent request, the server may now compare the client’s ETag with the ETag for the current version of the resource. If the ETag values match, meaning that the resource has not changed, then the server may send back a very short response with a HTTP 304 Not Modified status. The 304 status tells the client that its cached version is still good and that it should use that.
						</p>
						<p>
							However, if the ETag values do not match, meaning the resource has likely changed, then a full response including the resource’s content is returned, just as if ETag were not being used. In this case the client may decide to replace its previously cached version with the newly returned resource and the new ETag
						</p></div>
				
					<h3 class="stylenew">
						Explain the difference between Stateless and Stateful protocols. Which type is HTTP? Explain.	
					</h3>
						<div class="newstyle">
						<p>
							A stateless communications protocol treats each request as an independent transaction. It therefore does not require the server to retain any session, identity, or status information spanning multiple requests from the same source. Similarly, the requestor can not rely on any such information being retained by the responder.
							In contrast, a stateful communications protocol is one in which the responder maintains “state” information (session data, identity, status, etc.) across multiple requests from the same source.</p>
						<p>
							HTTP is a stateless protocol. HTTP does not require server to retain information or status about each user for the duration of multiple requests.
						</p>
						<p>
							Some web servers implement states using different methods (using cookies, custom headers, hidden form fields etc.). However, in the very core of every web application everything relies on HTTP which is still a stateless protocol that is based on simple request/response paradigm.
						</p></div>

					<h3 class="stylenew">
						Describe the key advantages of HTTP/2 as compared with HTTP/1.1
					</h3>
						<div class="newstyle">
						<p>
							HTTP/2 provides decreased latency to improve page load speed by supporting:</p>
						<ul>
							<li>Data compression of HTTP headers</li>
    						<li>Server push technologies</li>
    						<li>Loading of page elements in parallel over a single TCP connection</li>
    						<li>Prioritization of requests</li>
						</ul>
						<p>
							An important operational benefit of HTTP/2 is that it avoids the head-of-line blocking problem in HTTP 1.
						</p></div>

					<h3 class="stylenew">
						What is a MIME-type, what does it consist of, and what is it used for ? Provide an example.
					</h3>
						<div class="newstyle">
						<p>
							MIME is an acronym for Multi-purpose Internet Mail Extensions. It is used as a standard way of classifying file types over the Internet.
						</p>
						<p>
							Web servers and browsers have a defined list of MIME types, which facilitates transfer of files of a known type, irrespective of operating system or browser.
						</p>
						<p>
							A MIME type actually has two parts: a type and a subtype that are separated by a slash (/). For example, the MIME type for Microsoft Word files is application/msword (i.e., type is application and the subtype is msword).
						</p></div>
					
				</div>
			</div>				
	</main>

<!--footer part-->
	<footer>
	<!--contact us part-->
		<div class="contact">
			<h5>
				Contact Us.
			</h5>
			<p>
				Amazeriffic!
			</p>
			<p>
				No 112 Waxhaul Street
			</p>
			<p>
				Colombo, Sri Lanka.
			</p>
		</div>

		<div class="sitemap">
			<h5>
				Sitemap
			</h5>
			<ul class="li_float_left">
				<li>
					<a href="index.html">Home</a>
				</li>
				<li>
					<a href="#">About Us</a>
				</li>
				<li>
					<a href="#">Privacy</a>
				</li>
			</ul>
			<ul class="li_float_right">
				<li>
					<a href="#">Support</a>
				</li>
				<li>
					<a href="faq.html">FAQ</a>
				</li>
				<li>
					<a href="#">Careers</a>
				</li>
			</ul>
		</div>
	</footer>


</body>
</html>